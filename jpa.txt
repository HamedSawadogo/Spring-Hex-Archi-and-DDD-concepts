Plan propos√© pour ton PPT JPA Mastering
Slide 1 ‚Äì Titre

Titre : JPA Mastering ‚Äì Best Practices et pi√®ges √† √©viter
Sous-titre : Une vision senior pour concevoir des entit√©s et relations robustes

Nom / Date / Projet (optionnel)

Slide 2 ‚Äì Objectifs

Comprendre les relations JPA et leur impact SQL

√âviter les pi√®ges classiques (N+1, pagination, cascade, etc.)

Ma√Ætriser les value objects et cl√©s compos√©es

Optimiser transactions et performance

Appliquer des bonnes pratiques DDD / Aggregates

Slide 3 ‚Äì Les Relations JPA
Relation	Quand l‚Äôutiliser	Attention / Pi√®ge
@ManyToOne	Par d√©faut, relation simple	Probl√®mes N+1 si mal fetch
@OneToMany	Collections d√©pendantes	Souvent inutile c√¥t√© JPA, N+1 possible
@OneToOne	Vraie 1-1 en base	Attention aux joins inutiles
@ManyToMany	√Ä √©viter en prod	Perte de flexibilit√© ‚Üí pr√©f√©rer entit√© de liaison

mappedBy = c√¥t√© inverse (non propri√©taire)

C√¥t√© propri√©taire = FK, √©crit en base

Slide 4 ‚Äì Value Objects

@Embeddable ‚Üí d√©finit un objet valeur

@Embedded ‚Üí int√©gr√© dans la table de l‚Äôentit√©

@EmbeddedId ‚Üí cl√© primaire compos√©e

@ElementCollection ‚Üí collection technique, table implicite (ex : List<String>, Set<Adresse>)

Exemple rapide :

@Embeddable
class Adresse { String rue; String ville; }
@Entity class Client { @Embedded Adresse adresse; }

Slide 5 ‚Äì Transactions et Concurrence

@Version ‚Üí optimistic locking

@Lock(PESSIMISTIC_WRITE) ‚Üí cas critiques (paiement‚Ä¶)

@Transactional(readOnly = true)

D√©sactive dirty checking

√âvite flush inutile

Moins de m√©moire, plus rapide

Slide 6 ‚Äì Collections

Pr√©f√©rer Set √† List si l‚Äôordre n‚Äôa pas de sens

Pourquoi List = dangereux :

Hibernate cr√©e colonne d‚Äôindex

Insert en d√©but ‚Üí UPDATE massif

Probl√®mes de performance

List uniquement si ordre m√©tier r√©el

Slide 7 ‚Äì Cascade

‚ùå √âviter CascadeType.ALL par d√©faut

MERGE co√ªte cher sur grosses entit√©s

REMOVE supprime l‚Äôhistorique ‚Üí mauvais pour audit

Cascade = OK uniquement pour objets d√©pendants (ex : OrderLine ‚Üí Order)

Slide 8 ‚Äì Fetching

Toujours Fetch.LAZY

Charger par use-case (JOIN FETCH, DTO, EntityGraph)

‚ö†Ô∏è JOIN FETCH + pagination = faux ami ‚Üí r√©sultats incoh√©rents

Attention aux N+1 queries

Slide 9 ‚Äì @MapsId

Utilis√© quand FK fait partie de la PK

Garantit coh√©rence du mapping

Typique dans entit√©s de liaison enrichies

Slide 10 ‚Äì Soft Delete

Ne jamais supprimer les donn√©es m√©tier importantes

Marquer les entit√©s deleted = true

Filtrer automatiquement avec Hibernate :

@Where(clause = "deleted = false")


Permet audit, coh√©rence, historique

Slide 11 ‚Äì DDD / Aggregates

Relation JPA ‚â† relation m√©tier

Charger uniquement Aggregate root

Ne pas naviguer tout le graphe

Exemple : Order ‚Üí OrderLine, mais pas Customer ‚Üí Address ‚Üí Country‚Ä¶

Slide 12 ‚Äì R√®gles d‚Äôor

ManyToOne = standard, OneToMany = rare

Pas de ManyToMany en prod ‚Üí entit√© de liaison

Set > List sauf ordre m√©tier

Cascade limit√© ‚Üí objet d√©pendant uniquement

Fetch LAZY, charger par use-case

Soft delete > DELETE physique

Slide 13 ‚Äì Sch√©ma r√©capitulatif

Diagramme d‚Äôun Order Aggregate :

Order
 ‚îú‚îÄ OrderLine (Set, cascade PERSIST)
 ‚îî‚îÄ Payment (entit√© s√©par√©e)
Client (ref par ID, soft delete)


Montrer PK/EmbeddedId et @MapsId

Indiquer LAZY loading

Slide 14 ‚Äì Conclusion

JPA = outil pour charger des Aggregates coh√©rents

Toujours penser m√©tier avant technique

Appliquer ces r√®gles √©vite bugs, pertes de donn√©es, et probl√®mes perf

Slide 15 ‚Äì Questions / Notes

Lien vers ton cheat sheet

Notes perso sur performance / audits

üí° Style Pro recommand√©

Fond blanc ou gris clair

Titres gras + couleur contrast√©e

Sch√©mas simples pour relations et PK

Exemple de code avec fond clair / police monospace

Graphiques pour expliquer Lazy vs Eager fetch, cascade, soft delete